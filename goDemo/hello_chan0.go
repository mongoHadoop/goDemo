package main

import (
	"fmt"
)

func hello2(done chan bool) {
	fmt.Println("Hello world goroutine")
	done <- true
}
func main() {
	done := make(chan bool)
	go hello2(done)
	<-done
	fmt.Println("main function")
}
/**
在上述程序里，我们在第 12 行创建了一个 bool 类型的信道 done，
并把 done 作为参数传递给了 hello 协程。在第 14 行，我们通过信道 done 接收数据。这一行代码发生了阻塞，
除非有协程向 done 写入数据，
否则程序不会跳到下一行代码。于是，
这就不需要用以前的 time.Sleep 来阻止 Go 主协程退出了。
<-done 这行代码通过协程（译注：原文笔误，信道）done 接收数据，
但并没有使用数据或者把数据存储到变量中。这完全是合法的。
现在我们的 Go 主协程发生了阻塞，等待信道 done 发送的数据。
该信道作为参数传递给了协程 hello，hello 打印出 Hello world goroutine，
接下来向 done 写入数据。当完成写入时，Go 主协程会通过信道 done 接收数据，于是它解除阻塞状态，打印出文本 main function
**/

/**
通过信道进行发送和接收

如下所示，该语法通过信道发送和接收数据
data := <- a // 读取信道 a
a <- data // 写入信道 a

信道旁的箭头方向指定了是发送数据还是接收数据。
在第一行，箭头对于 a 来说是向外指的，因此我们读取了信道 a 的值，并把该值存储到变量 data。
在第二行，箭头指向了 a，因此我们在把数据写入信道 a。

发送与接收默认是阻塞的

发送与接收默认是阻塞的。这是什么意思？当把数据发送到信道时，程序控制会在发送数据的语句处发生阻塞，直到有其它 Go 协程从信道读取到数据，才会解除阻塞。与此类似，当读取信道的数据时，如果没有其它的协程把数据写入到这个信道，那么读取过程就会一直阻塞着。
信道的这种特性能够帮助 Go 协程之间进行高效的通信，不需要用到其他编程语言常见的显式锁或条件变量。

信道的代码示例
**/